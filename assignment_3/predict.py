# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vbyGJUpfhgyjBJYk_Qq6dioZ0eHkdbeS
"""

import numpy as np
from matplotlib import pyplot as plt
# %matplotlib inline

import random

#genertaing random numpy arrray of size 2*250 i.e with 250 data points
#numbers are in the range 10 to 20
random1= np.random.uniform(0,2, size=(50, 2))
#generating another in the range 0 to 10
random2= np.random.uniform(-2,0, size=(50, 2))

y1=np.full((50,1),1)
y2=np.full((50,1),-1)

print("plot for toy data set used and a tentative hyperplane : ")
for val, inp in enumerate(random1):
     plt.scatter(inp[0], inp[1], marker='+', linewidths=5,color='red')
for val, inp in enumerate(random2):
     plt.scatter(inp[0], inp[1], marker='+', linewidths=5,color='blue')
#tentative hyperplane between thw two data sets
plt.plot((-2,2),(2,-2))
plt.show()

def svm_function(x,y):
  """
  applying gradient descent on the weights
  x:float array
  has the dimensions on which model is trained
  y:int array
  has omly 2 numbers 1 and -1 which helps us to classify data
  return:
  w:int array
  contains the weight of the model
  out: 
  contains the predicted values for the data
  """
    #initilizing weight
  w=np.zeros(2)
    #initialize learning rate
  l_rate =1
    #epoch
  epoch =1000
    #output list
  out = []
    #training svm
  for e in range(epoch):
      for i, val in enumerate(x):
        val1 = np.dot(x[i], w)
        if (y[i]*val1 < 1):
          w = w + l_rate * ((y[i]*x[i]) - (2*(1/epoch)*w))
        else:
          w = w + l_rate * (-2*(1/epoch)*w)
        
  for i, val in enumerate(x):
      out.append(np.dot(x[i], w))
  
    
  return w, out



#concatenating data points
data=np.concatenate((random1,random2))
y=np.concatenate((y1,y2))

weights,output=svm_function(data,y)

u=np.full((1,2),0)

x1=input("input x1: ")
x2=input("input x2: ")

u[0]=[x1,x2]

result = []
for i, val in enumerate(u):
        result.append(np.dot(u[i], weights))

final=np.zeros(len(u))
for i,val in enumerate(result):
    if(result[i]<-1):
        final[i]=-1
    else:
        final[i]=1

print("results from custom svm function : ")
print(final)
print("weights of the model are :")
print(weights)

print("NOW COMPARING THE MODEL WITH THE SVM LIBRARY FROM SKLEARN : ")

from sklearn import svm
clf = svm.SVC(kernel='linear', C=1,gamma=1)
clf.fit(data,y)

print('predicted value: ')
print(clf.predict(u))

